一：当底盘上电遥控器未上电时，出现过底盘失控情况。（已通过在遥控器解析底层中舍弃绝对值超过1的数据来解决）
当接收机上电，但遥控器未上电时，接收机会向C板发送：Data.Right_X = -1.16515148 或 -1.5515151 , Data.Right_Y = -1.5515151 , Left_X = -1.5515151 , Left_Y = -1.5515151 , Yaw = -1.5515151。原因未知。
但此时DUBS_Manage_Object.Rx_Buffer[0]=0xFF,剩余Rx_Buffer的值均为0.而且有时候这个DUBS_Manage_Object.Rx_Buffer[0]=0xFF的现象还测不到，有时候DUBS_Manage_Object.Rx_Buffer[0]正常=0x00；
本Bug触发方法：遥控器处于断电状态。c板先上电，之后再给接收机上电，就可以复现此Bug
此结果会造成电机收到错误数据导致失控。

二：当行进时可能突然失控，然后底盘失去动力，此时需要复位开发板才可以。（感觉已解决，但是怕在HardFault_Handler中二次错误，所以最好改成看门狗）
（失控时速度不大，感觉像是电机失去动力，依靠惯性移动，但此时电调还是上电状态，接收机也还是上电状态，所以不像是电机断电无动力或是接收机断电向电机发送0速度数据）
猜测原因可能是程序跑飞，死机。若再出现此bug，可以先不复位开发板，然后把serialplot串口接到电脑上显示遥控器通道值，看看遥控器动时，能不能收到数据，若能收到，则此时程序未死机，只是以某种原因导致电机不听指令。还可调试的思路是，当此bug出现时，看一看CAN发送缓存区的数据有没有，电机的Target-Omega有没有数值。
现在已对HardFault_Handler函数进行处理，当进入此函数后，C板会快速响10下，后自动执行HAL_NVIC_SystemReset()软件复位。

找到原因了：serialplot的串口RX和TX碰到一起就会导致进入HAL_NVIC_SystemReset()

三：右上角的电机卡顿，需要机械重装。（基本已解决，但是还是很涩）

四：当P值较大时，电机速度给大，可能失控：（已找到应对方法）
{
根据M3508手册，空载转速为482rpm，对应角速度为50.47rad/s。产生的线速度为3.75m/s，与底盘极限测试的最大不失控速度相吻合，所以当电机不失控时，空载能产生的最大速度即为3.75m/s，实际负载可能更低，在3m/s左右（实测最大速度在3.125m/s），属于电机参数限制。

当P过大时，可能导致输出剧烈波动，使电机失去闭环能力导致失控
}

五：底盘有个悬挂断了，要重新安装。（已解决）

六：现在单个电机能产生的线速度最大为3.8m/s（空载） 3.2m/s（底盘在地上跑的负载情况）。所以当Vx+Vy+w超过3.2时，底盘不会按照理论的路径以及姿态前进

先做云台和发射机构，等最后再回过头引入力控底盘，去算功率，以及牵引力补偿，错误处理改成看门狗，加入各种掉线管理逻辑

七：该版本又出现新的bug，有时候底盘会失控，此时遥控器也无反应，失控大约1-2s后就自行恢复，但是没有听到进入HardFault_Handler的bb响，而且触发概率较大（12月1日晚一个小时内至少触发10次）。
若不加最大速度等比限幅，那底盘电机就不能引入积分项，因为电机物理限制，线速度超过3.2m/s后就无法增加，积分项会一直累加。所以可考虑更换减速箱，增大最大转速。

12月2日：17-1版本测试了很长时间都没有出现bug，17-2版本测试一会就出现两次新增bug和进入HardFault_Handler的bug，而且操作手感也很差，没有17-1版本好操控，感觉是运动缩放的原因，所以还是延用17-1的版本
对17-1改善：当MAX_SPEED = 0.8f;   MAX_OMEGA = 4.15f;时，底盘单个轮子的最大线速度速度也不会超过3.2m/s。可以添加一个狂暴模式，在以底盘为坐标系下的速度值，此时不管实际姿态如何，MAX_SPEED = 3.0f;   MAX_OMEGA = 2.0f*PI;

12月6日：MPU6050的引脚一定要做绝缘处理，如果排针接触到金属就会短接，短接后就会出现数据传输错误，在serialplot中的表现是，数据发送缓慢，且发送的数据不对
此时串口发送的速度就会降低，感觉是我的I2C发送接收函数写的是堵塞式的，当MPU6050的I2C引脚短接后，就会紊乱，导致C板接收的I2C数据紊乱，就会使那几个堵塞函数一直运行

stlink也要做绝缘处理

MPU6050有时候上电读取的角速度是真实速度的8倍左右，有时候又正常
关键问题：当 MPU6050 偶尔复位或初始化不完整时，可能会恢复默认量程 ±250°/s（灵敏度为 131 LSB/(°/s)），此时：

如果代码仍按 ±2000°/s 的灵敏度（16.4）计算，实际读取值会放大约 8倍（131/16.4 ≈ 8）

GM6020用电调自带的电流环也炸电流环：你的这个原因应该是速度传感器的反馈精度较差，导致当前速度值出现了问题，导致速度环的误差计算有问题，导致速度环的输出有问题，速度环的输出就是目标电流，目标电流有问题，那就意味着控制会炸掉，所以当前电流也会表现出问题，用陀螺仪的数据代替电调回传的角速度就行了。

12月8日：陀螺仪漂移导致速度环积分项一直累计，时间长了，云台就漂移


12月10日：在使用角度环时，为什么在角度快速变化时会出现反向扭动和速度环积分项骤增的情况。
1. 速度环积分项没有分离机制
// 当前速度环PID初始化：积分项很大（10000.0f），没有积分分离
GM6020_Yaw.PID_Omega.Init(2000.0f, 10000.00f, 8.0f, 10.0f);
问题：当角度快速变化时，角度环输出（即速度环目标值）会突变，导致速度环误差巨大，积分项会迅速累积到一个很大的值。
// 改为：
GM6020_Yaw.PID_Omega.Init(2000.0f, 5000.00f, 8.0f, 10.0f, 
                           10000.0f, 30000.0f, 0.001f, 
                           0.0f, 0.0f, 0.0f, 30.0f);
// 关键参数：
// - I_Out_Max: 10000.0f (积分限幅)
// - Out_Max: 30000.0f (输出限幅)  
// - I_Separate_Threshold: 30.0f (积分分离阈值，误差大于30rad/s时不积分)

要想防止小陀螺后改为角度控制模式时，角度积累，云台一直转。不要直接在CAN_RxCpltCallback将当前角度规划到0-2PI。这样的话角度会不连续，它会导致角度在0-2π之间跳变，这在PID控制中会造成严重问题：

问题分析：
当目标角度转到0°时，由于自然界中必定存在的PID过充，会让云台稍稍偏移一点点角度距离0°，这时当前角度就会变为大概1.999999PI，这时又会继续旋转，以此类推

12月15日：在使用MPU6050时，晃动c板会导致云台的Yaw轴电机持续高频左右抖动。原因为，当晃动c板时，会连带c板与陀螺仪连接的I2C线抖动，可能因为接触不良导致MPU6050会向c板发送一个极大的异常值，大概在30 rad/s左右，会造成Yaw轴PID速度环中的P项极大，因为该极大异常值会导致瞬时误差极大，同时会造成D项极大，因为误差变化的速率极大，虽然这个MPU6050因接线晃动而向C板发送的极大极大异常值在触发时只会发送1-2个左右的异常极大值，但是Yaw的PID速度环只要接收到一次，速度环就炸环了，随后就会一直抖动。目前的解决办法是对MPU6050的滤波算法升级，对异常值进行舍弃，和对一阶滤波器的滤波系数降低来提高滤波效果。同时对PID的微分项加入滤波和微分项输出限幅
    //  异常值检测
    if (fabsf(raw_gyro_z - prev_raw) > OUTLIER_THRESHOLD) {
        // 数据突变过大，认为是异常值，使用上一次的有效值
        raw_gyro_z = prev_raw;
    }
一阶滤波器的系数不能太小不然会引入延迟，异常值检测也不是能干净的滤波掉那些极大异常值，因为MPU6050在接线不良时，不是一次性就发送那个极大异常值，而是快速，但是渐进的发送。假如正常值是0rad/s，极大异常值是30rad/s，当异常时，MPU6050向C板发送的数据不是0 - 30，而是0 - 4 - 10 - 15 ... - 30。这就导致不能很好的滤掉这些异常值。
所以目前的方法只能一定程度上减少晃动MPU6050接线时触发Yaw电机抖动时的概率和减少抖动的程度，不能完全解决。下一步的方法是使用c板板载的陀螺仪代替MPU6050，这样就可以规避接线晃动导致数据传输错误的问题。

Yaw轴云台当目标速度由（举例）10rad/s变到0rad/s时，电机不能立马变为0rad/s，而是在接近0rad/s时缓慢变为0rad/s，原因是，云台在目标速度为0之前积累了很多积分，当目标速度快速变为0时，那些积分项不能快速释放，所以实际云台速度不能立马
归0.

Yaw轴云台当目标速度由（举例）10rad/s变到0rad/s时，当实际速度和目标速度均为0rad/s后，积分项依然存在，并不为0。原因是：假如云台没有摩擦力，那么云台在目标速度为0之前积累的那些积分，在目标速度变为0时，会全部变为速度释放出来，但是由于云台存在静摩擦力，所以当积分项累计的那些输出对应的电压所对应的力小于Yaw云台的静摩擦力时，这些力虽然电机依然在输出，但是无法对抗静摩擦力来让电机运动，所以这些积分项就释放不出去，一直存在。

解决办法是：
对PID 积分项底层进行改造。
    bool in_dead_zone = (Target == 0 && abs_error < Dead_Zone);

    if(!in_dead_zone){
	...
     }
    else//为了防止静摩擦力的存在，当电机停止时，残留的积分项输出的力不足以克服积分项让电机旋转，但是残留积分却消耗功率
    {
        // 在死区内，不累积新的积分
        // 缓慢释放已有积分
        if (fabsf(Integral_Error) > 0.0001f)
        {
            // 每周期衰减5%
            Integral_Error *= 0.95f;
        }
    }

同时在main中加入
//加上这一部分可以有效消除当速度为零时依然有积分项存在的情况，也可以当目标速度变为0时快速释放积分项。

//      // 在云台控制部分添加更智能的积分管理：
//      static float last_gimbal_target_speed = 0.0f;
//      static uint32_t target_zero_timer = 0;
//      static bool integral_release_active = false;

//      // 1. 当目标速度接近0时，开始计时
//      if (fabsf(gimbal_target_speed) < 0.01f)
//      {
//          target_zero_timer++;
//          
//          // 只有当目标速度为0持续一段时间（如100ms）且实际速度也接近0时，才开始释放积分
//          if (target_zero_timer > 100)  // 100ms = 100个控制周期（假设1ms周期）
//          {
//              float current_speed = gimbal_relative_omega;
//              
//              // 实际速度也很小，开始释放积分
//              if (fabsf(current_speed) < 0.5f)  // 更严格的阈值：0.5 rad/s
//              {
//                  integral_release_active = true;
//                  
//                  // 获取当前积分值
//                  float current_integral = GM6020_Yaw.PID_Omega.Get_Integral_Error();
//                  
//                  // 缓慢释放积分（每周期减少10%，而不是20%）
//                  if (fabsf(current_integral) > 0.001f)
//                  {
//                      GM6020_Yaw.PID_Omega.Set_Integral_Error(current_integral * 0.9f);
//                  }
//              }
//          }
//      }
//      else
//      {
//          // 目标速度非0，重置计时器
//          target_zero_timer = 0;
//          integral_release_active = false;
//      }

//      // 2. 当目标速度方向发生显著反转时，清零积分（保留原有逻辑，但调整阈值）
//      if (last_gimbal_target_speed * gimbal_target_speed < -1.0f)  // 提高阈值，避免微小波动触发
//      {
//          // 速度方向发生显著反转（幅度超过1 rad/s），清零积分项
//          GM6020_Yaw.PID_Omega.Set_Integral_Error(0.0f);
//      }

//      // 3. 当目标速度从0快速变为非0时，如果之前正在释放积分，立即停止释放
//      if (fabsf(last_gimbal_target_speed) < 0.01f && fabsf(gimbal_target_speed) > 0.5f)
//      {
//          if (integral_release_active)
//          {
//              // 立即停止积分释放，保留当前积分值
//              integral_release_active = false;
//              
//              // 可选：如果积分项太小，给它一个初始值以快速响应
//              float current_integral = GM6020_Yaw.PID_Omega.Get_Integral_Error();
//              if (fabsf(current_integral) < 0.1f && fabsf(gimbal_target_speed) > 2.0f)
//              {
//                  // 预置一个小的积分值，方向与目标速度相同
//                  float preload_integral = gimbal_target_speed * 0.001f;  // 预加载值
//                  GM6020_Yaw.PID_Omega.Set_Integral_Error(preload_integral);
//              }
//          }
//      }

//      last_gimbal_target_speed = gimbal_target_speed;



由于MPU6050零漂的原因，积分项会一直累计，解决办法是在速度环PID加上误差死区。

12月16日：MPU6050的数据有延迟。
原因：我给的采样率和带宽都太低了。

我设置的
MPU6050_WriteReg(MPU6050_SMPLRT_DIV, 0x09);  // 采样分频寄存器

MPU6050内部采样率固定为1kHz = 1000Hz
SMPLRT_DIV寄存器用于分频：

输出采样率 = 1000 / (1 + SMPLRT_DIV)

你的设置：SMPLRT_DIV = 0x09 = 9
输出采样率 = 1000 / (1 + 9) = 100Hz

即10ms才更新一个数据，但是我main中是1ms就处理一次陀螺仪数据，所以有9次用的都是旧数据

我设置的
MPU6050_WriteReg(MPU6050_CONFIG, 0x06);

根据MPU6050数据手册：

DLPF_CFG	加速度计带宽	陀螺仪带宽 	延迟	       备注
0	          260Hz	           256Hz	        0.98ms	最快
1	          184Hz	           188Hz	          2.9ms	
2	           94Hz	             98Hz	          3.9ms	常用
3	           44Hz	             42Hz	          5.9ms	
4	           21Hz	             20Hz	          9.9ms	
5	           10Hz	             10Hz	      17.85ms	
6	             5Hz	               5Hz	      33.48ms	我现在的设置
7	             保留	               保留	           保留	

先明确一些概念：
1. 采样率 (Sample Rate)
定义：每秒从连续信号中采集并组成离散信号的样本数量。

单位：赫兹（Hz）

作用：决定时间分辨率，即多久测量一次。

比喻：拍照的连拍速度。每秒拍10张（10Hz）和每秒拍1000张（1000Hz）的区别。

2. 带宽 (Bandwidth)
定义：传感器能够准确测量的最高频率信号。

单位：赫兹（Hz）

作用：决定频率响应，即能测量多快的信号变化。

比喻：相机的快门速度。高速快门能捕捉快速运动，低速快门则会模糊。

采样率越大噪声越大。 带宽越大噪声越大。
采样率越大延时越小。 带宽越大延时越小。

在配置BMI088时也要注意这一点，如果带宽给的太大比如2000Hz，那么在陀螺仪静止时，也会有0.1左右的反馈值，噪声太大了  

12月22日：
云台Pitch轴对机械要求较高，连杆之间的缝隙不能太大，连杆之间的摩擦力也一定要小。
加入重力补偿前馈来对抗重力。
积分项不能无脑消除。
现在pitch轴有一些问题。我的Pitch轴云台是有限位的，以云台pitch轴水平时为0°，云台pitch抬头为0°到PI范围，以云台pitch低头为0°到-PI范围。我的云台范围大概在-45° - 45°，当然这个值不准确，后期要再精确测量。云台的pitch轴由遥控器的右摇杆Y轴控制，摇杆返回的值被映射到-1 - 1，再乘上程序中规定的速度系数，云台的pitch轴也就收到了它将要运动的速度信息。假设我波动摇杆使pitch收到了一个向上的速度，刚开始pitch轴会按照目标速度运动，但是当达到上限位时，由于机械原因，pitch无法再继续运动，此时pitch实际速度为0，但是此时由于摇杆没有在0位置，pitch轴依然会有目标速度，这就会导致目标速度与实际速度直接一直有一个误差值，会导致i项一直积累，这会导致云台空耗能量，而且当我摇杆反向波动，让pitch负向运动时，pitch轴不会立即响应，而是先等它把那些积累的积分项消除后，才能响应。还有两个问题。第一：pitch的积分项不能随便就消除，因为当pitch没有到达限位之前，积累的积分项是用于抵抗当下角度重力用的。第二：由于pitch系统的惯性和粗糙的机械，连接件之间有许多虚位，当我给pitch一个速度直到它装上限位后，此时限位那个角度我是不确定的，他可能会上下浮动一些度数，我无法准确得出上下限位的那个角度。这会出现一个问题，如果程序设置的是，当pitch超过限位角度后，目标速度就变为0，假设限位角度软件设置的是45°，我pitch轴收到向上的速度后，从0°运动到限位角度45°后，由于上述的惯性和机械的原因，它可能会冲出一小角度，此时pitch的角度可能为45.5°，这样目标角度就被程序限制为0了，那以后我遥控器无论怎么控制，pitch的目标速度都只能为0，因为它无法自发的从45.5°再回到限位角度45°以内

解决方法：

	//新增：pitch角度限幅，速度限幅
	#define PITCH_ANGLE_UP_MAX 0.82f //单位：rad
	#define PITCH_ANGLE_DOWN_MAX -0.18f

        //处理pitch限位情况.按理说是要在限位时消除冲装限位时积累的积分项时，但是当前版本的前馈不是很好，积分消除完之后纯靠前馈感觉不太行，而且不消除这个积分项似乎也能行，就先不管了
        // 定义软限位减速区宽度（5°转为弧度）
        #define SOFT_LIMIT_ZONE (5.0f * PI / 180.0f)

        // 处理pitch限位情况
        if(pitch_angle >= PITCH_ANGLE_UP_MAX && dr16.Get_Right_Y() > 0.0f) {
            // 已经超过上限且试图继续上抬，禁止
            GM6020_Pitch.Set_Target_Omega(0);
        }
        else if(pitch_angle <= PITCH_ANGLE_DOWN_MAX && dr16.Get_Right_Y() < 0.0f) {
            // 已经超过下限且试图继续下低，禁止
            GM6020_Pitch.Set_Target_Omega(0);
        }
        else {
            // 正常操作区或反向操作区，计算目标速度
            float pitch_target_speed = dr16.Get_Right_Y() * 1.5f * PI;
            
            // 检查是否在软限位减速区内
            if (dr16.Get_Right_Y() > 0.0f && pitch_angle > PITCH_ANGLE_UP_MAX - SOFT_LIMIT_ZONE) {
                // 向上运动且在软限位区，速度按比例衰减
                float dist = PITCH_ANGLE_UP_MAX - pitch_angle;
                float scale = dist / SOFT_LIMIT_ZONE; // 0到1的比例
                Math_Constrain(&scale, 0.0f, 1.0f);
                pitch_target_speed *= scale;
            }
            else if (dr16.Get_Right_Y() < 0.0f && pitch_angle < PITCH_ANGLE_DOWN_MAX + SOFT_LIMIT_ZONE) {
                // 向下运动且在软限位区，速度按比例衰减
                float dist = pitch_angle - PITCH_ANGLE_DOWN_MAX;
                float scale = dist / SOFT_LIMIT_ZONE; // 0到1的比例
                Math_Constrain(&scale, 0.0f, 1.0f);
                pitch_target_speed *= scale;
            }
            
            // 设置最终的目标速度
            GM6020_Pitch.Set_Target_Omega(pitch_target_speed);
        }


12月25日：
当 yaw 逆时针旋转时，pitch 会自己升高。反之下降。当 yaw 顺时针快速旋转时，快速让 pitch 向下，yaw 速度会失控急剧增大。当 yaw  逆时针快速旋转时，快速让 pitch 向上， yaw 速度会失控急剧增大。看看可能是哪里的问题。首先正常控制情况下我的步兵云台是没问题的，而且yaw失控转动时那个速度，特别像我给pid限幅16384那个数值对应的速度。

因为我的陀螺仪是用泡沫胶带粘到pitch末端的，所以当我云台Yaw，快速向逆时针或顺时针旋转时，陀螺仪x方向相对云台的炮管方向会有一个向左或向右的倾斜，我感觉是因为这个小小的倾角导致的yaw旋转，使pitch也有了分量
会不会是我pitch轴再保证pitch水平时编码器角度为0时的编码器偏移值就有误？

2026 - 1 - 3
问题：bmi088每次上电后加速度的值可能都不一样。每次上电，角速度或者加速度都会上下浮动一些。比如说当我陀螺仪平放在桌子上时，加速度x轴有时候是0.17，但是我复位一下开发板，他又变成0.07左右了。加速度z轴有时候上电是9.8，但是当我复位一些，又变成9.3了.我也考虑了随机漂移的情况，但是这个每次上电变化的都有规律，比如说z轴的加速度，有时候上电是9.8有时候是9.2，他基本上就只会在这两个值选一个，如果是漂移的话，应该是随机的吧

原因：



在定时器中执行任务时，注意各个中断的优先级关系
问题：对于dr16的串口接收中断：
如果定时器的中断dr16串口接收中断优先级高或者定时器中断中的内容执行花费的时间更长，会只有上电的时候单片机能收到一次dr16的数据，后面就收不到了。
原因：因为你的 DR16 串口是持续高速流（100000bps、18字节一帧、频率还挺高），而 UART 的接收在硬件里只有很小的缓存能力（基本就是移位寄存器 + 1字节数据寄存器）。它要求 CPU 必须及时进 USART 中断把字节读走（或由 DMA搬走），不然就会出事。

当你把定时器中断优先级设得更高（或它执行得很久、很频繁）时，会发生这种链式反应：

1) 高优先级 TIM ISR 会“抢占”USART ISR

Cortex-M 的中断是 优先级抢占式：高优先级中断在运行时，低优先级中断进不来（只能挂起等着）。

如果 TIM 中断很频繁（比如 1ms）且 ISR 里做了不少事，那么 USART3 的中断就可能一直排队。

2) USART 这边字节还在不停进来 → 很快溢出（ORE）

DR16 数据一来，UART 硬件把字节放到 RDR/DR。

如果 CPU 迟迟不来读，新的字节又到了，硬件就会置位 ORE（Overrun Error）：表示数据被覆盖/丢失。

一旦 ORE 出现，你这帧就乱了，而且 HAL 层很可能会进入“错误/忙”状态。

3) HAL 接收可能因此“停住”，表现就是：只收到一次

你用的是 ReceiveToIdle_IT 这套：

第一次上电时，系统负载还小或碰巧时序刚好 → 能触发一次 RxEventCallback

后面 TIM 抢占让 USART 长时间得不到服务 → ORE/错误出现

如果你没写 HAL_UART_ErrorCallback() 去清错 + 重新挂接收，HAL 可能就不再继续接收 → 看起来就是“后面永远收不到”。

4) 为什么你“降低 TIM 优先级”就好了

因为这样 USART3 的中断可以更及时执行：

字节一来就被读走，不会积压到溢出

RxEventCallback 能持续触发

你的回调里又会重新 ReceiveToIdle_IT，链路就一直跑通

一句话总结

UART 接收是“实时性很强”的活：如果被更高优先级、耗时的中断长期压着不让跑，就会出现 溢出(OE/ORE) → 丢数据/HAL停接收 → 只收一次。



问题：serialplot里总是出现e级别的数据，且接线没用抖动：
原因：serialplot发送调用的频率太高了，上一个还没发过去，下一个新数据就又来了，数据一致处于覆盖或被截断状态

问题：有时候上电四个轮子都能转，有时候上电就一个轮子能转：

原因：1) 你把 CAN 接收中断开得太早，回调可能在电机对象 Init 之前就被打进来（典型随机问题）

在 Task_Init() 里你是这样做的（节选）：

CAN_Init(&hcan1, CAN_Callback_Function);   // 这里已经 HAL_CAN_Start + 使能FIFO中断了
...
Chassis.Init();                            // 电机对象的 CAN_Manage_Object/CAN_Tx_Data 指针在这里才分配


CAN_Init() 里会：

HAL_CAN_Start(hcan);

__HAL_CAN_ENABLE_IT(hcan, CAN_IT_RX_FIFO0_MSG_PENDING);

__HAL_CAN_ENABLE_IT(hcan, CAN_IT_RX_FIFO1_MSG_PENDING);

也就是说：只要电机上电后在总线上开始回传 0x201~0x204（非常常见），你的 CAN 中断随时会进入，然后执行：

Chassis.Motor[i].CAN_RxCpltCallback(...)


但这时 Motor[i] 还没 Init()，电机类里关键成员还没被正确绑定：

CAN_Manage_Object（后面 Data_Process() 会解引用它）

CAN_Tx_Data（虽然接收回调里暂时不用，但对象整体状态可能被写乱）

以及首次编码器基准等状态

这类“中断早到一步”的问题，最典型的表现就是：有时正常、有时异常，而且异常形态不固定。

最小改动修复：在 CAN 回调最前面加初始化完成保护，加init finished标志位处理


问题：按一次复位键感觉板子就死了，电机也控制不了了，而且再按复位键也没用：

原因：你这个“按一次复位键板子就像死了、再按也没用”的现象，基本就是你在 CAN 接收中断里 return 太早，导致 FIFO 里的报文没有被取走——中断标志一直挂着 → CPU 反复进 CAN 中断（中断风暴） → 主循环/定时器/任务都跑不起来，于是看起来“板子死了、电机也控制不了了”。

你现在 drv_can.c 里是这样写的（两路 FIFO 都一样）：

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    if (init_finished == false)
    {
        return;   // ❌ 这里直接 return，没有 HAL_CAN_GetRxMessage()
    }
    ...
    HAL_CAN_GetRxMessage(...);   // 只有 init_finished==true 才取走报文
}

为什么上电正常、按复位死？

上电时：电机/总线回传可能还没立刻刷满 FIFO，你能较快走到 init_finished = true，之后一切正常。

复位时：电机早就在发 0x201~0x204 了，你 MCU 一起来就开了 CAN RX 中断，立刻进 ISR，但 init_finished 还是 false，于是 一直 return、不清 FIFO → 直接锁死。

你就在 drv_can.c 这样改：哪怕 init 未完成，也必须先把 FIFO 读出来“丢掉”，清掉中断
